<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Call</title>
</head>
<body>
    <div class="main-container">
        <div class="header">
            <h3 id="label-username">Join a Call</h3>
            <div>
                <input id="username" placeholder="Enter your username">
                <button id="btn-join" class="btn">Join Room</button>
            </div>
        </div>

        <div class="main-grid-container">
            <div id="video-container">
                <video id="local-video" autoplay playsinline muted></video>
                <button id="btn-toggle-audio" class="btn">Mute</button>
                <button id="btn-toggle-video" class="btn">video on</button>
            </div>
            <div id="chat">
                <h3>Chat</h3>
                <div id="messages">
                    <ul id="message-list"></ul>
                </div>
                <div>
                    <input id="msg" placeholder="Type a message...">
                    <button id="btn-send-msg" class="btn btn-send-msg">Send Message</button>
                </div>
                <button id="btn-share-screen" class="btn">Share Screen</button>
            </div>
        </div>
    </div>

    <script>
        console.log('in main.js!');

        var mapPeers = {}; // Holds all peers
        var localStream;
        var usernameInput = document.querySelector('#username');
        var btnJoin = document.querySelector('#btn-join');
        var username;
        var webSocket;
        
        function dcOnMessage(event) {
            console.log('Message from Data Channel:', event.data);
        }
        
        function webSocketOnMessage(event) {
            const parsedData = JSON.parse(event.data);
            const peerUsername = parsedData['peer'];
            const action = parsedData['action'];
            const message = parsedData['message'];
        
            // Skip self messages
            if (username === peerUsername) return;
        
            if (action === 'new-peer') {
                if (peerUsername in mapPeers) {
                    console.warn(`Connection with ${peerUsername} already exists.`);
                    return;
                }
                console.log(`New peer connected: ${peerUsername}`);
                const receiverChannelName = message['receiver_channel_name'];
                createOffer(peerUsername, receiverChannelName);
            } else if (action === 'new-offer') {
                const offer = message['sdp'];
                const receiverChannelName = message['receiver_channel_name'];
                createAnswer(peerUsername, offer, receiverChannelName);
            } else if (action === 'new-answer') {
                const answer = message['sdp'];
                const peer = mapPeers[peerUsername][0];
                peer.setRemoteDescription(new RTCSessionDescription(answer))
                    .then(() => {
                        console.log('Remote description set');
                        
                        // Add stored ICE candidates if they exist
                        const candidates = mapPeers[peerUsername][1] || []; // Default to empty array if undefined
                        if (Array.isArray(candidates)) {
                            candidates.forEach(candidate => {
                                peer.addIceCandidate(candidate)
                                    .then(() => console.log('ICE candidate added'))
                                    .catch((err) => console.error('Error adding ICE candidate:', err));
                            });
                            mapPeers[peerUsername][1] = []; // Clear candidates after adding
                        } else {
                            console.error('ICE candidates are not an array:', candidates);
                        }
                    })
                    .catch((err) => console.error('Error setting remote description:', err));
            } else if (action === 'new-ice-candidate') {
                const candidate = new RTCIceCandidate(message['candidate']);
                const peer = mapPeers[peerUsername][0];
                
                // Ensure ICE candidates are stored as an array
                if (!Array.isArray(mapPeers[peerUsername][1])) {
                    mapPeers[peerUsername][1] = []; // Initialize as an array if not already
                }
        
                // Store ICE candidates until the remote description is set
                if (peer.signalingState !== 'stable') {
                    mapPeers[peerUsername][1].push(candidate);
                    console.log('Stored ICE candidate for later');
                } else {
                    peer.addIceCandidate(candidate)
                        .then(() => console.log('ICE candidate added'))
                        .catch((err) => console.error('Error adding ICE candidate:', err));
                }
            }
        }
        
        btnJoin.addEventListener('click', () => {
            username = usernameInput.value.trim();
        
            if (!username) return;
        
            usernameInput.disabled = true;
            usernameInput.style.visibility = 'hidden';
            btnJoin.disabled = true;
            btnJoin.style.visibility = 'hidden';
        
            const loc = window.location;
            const wsStart = loc.protocol === 'https:' ? 'wss://' : 'ws://';
            const serverHost = 'localhost:8000';
            const wsPath = '/ws/call/';
            const endPoint = wsStart + serverHost + wsPath;
        
            webSocket = new WebSocket(endPoint);
        
            webSocket.addEventListener('open', () => {
                console.log('WebSocket connection opened');
                sendSignal('new-peer', {});
            });
        
            webSocket.addEventListener('message', webSocketOnMessage);
            webSocket.addEventListener('close', () => console.log('WebSocket connection closed'));
            webSocket.addEventListener('error', (err) => console.error('WebSocket error:', err));
        });
        
        const constraints = { video: true, audio: true };
        const localVideo = document.querySelector('#local-video');
        const btnToggleAudio = document.querySelector('#btn-toggle-audio');
        const btnToggleVideo = document.querySelector('#btn-toggle-video');
        
        let audioTracks = [];
        let videoTracks = [];
        
        // Access the user's media devices
        navigator.mediaDevices.getUserMedia(constraints)
            .then((stream) => {
                localStream = stream;
                localVideo.srcObject = localStream;
                localVideo.muted = true;
        
                // Get audio and video tracks
                audioTracks = stream.getAudioTracks();
                videoTracks = stream.getVideoTracks();
        
                // Enable buttons if tracks are available
                if (audioTracks.length > 0) {
                    btnToggleAudio.disabled = false;
                }
                if (videoTracks.length > 0) {
                    btnToggleVideo.disabled = false;
                }
        
                // Set initial button states
                btnToggleAudio.innerHTML = 'Mute';
                btnToggleVideo.innerHTML = 'Video Off';
            })
            .catch((error) => console.error('Error accessing media devices:', error));
        
        // Toggle audio
        btnToggleAudio.addEventListener('click', () => {
            if (audioTracks.length > 0) {
                const audioTrack = audioTracks[0];
                audioTrack.enabled = !audioTrack.enabled;
        
                // Update button label
                btnToggleAudio.innerHTML = audioTrack.enabled ? 'Mute' : 'Unmute';
                console.log(`Audio track enabled: ${audioTrack.enabled}`);
            }
        });
        
        // Toggle video
        btnToggleVideo.addEventListener('click', () => {
            if (videoTracks.length > 0) {
                const videoTrack = videoTracks[0];
                videoTrack.enabled = !videoTrack.enabled;
        
                // Update button label
                btnToggleVideo.innerHTML = videoTrack.enabled ? 'Video Off' : 'Video On';
                console.log(`Video track enabled: ${videoTrack.enabled}`);
            }
        });
        
        function sendSignal(action, message) {
            webSocket.send(JSON.stringify({ peer: username, action: action, message: message }));
        }
        
        function createOffer(peerUsername, receiverChannelName) {
            const peer = new RTCPeerConnection();
            addLocalTracks(peer);
        
            const dataChannel = peer.createDataChannel('channel');
            dataChannel.addEventListener('message', dcOnMessage);
        
            const remoteVideo = createVideo(peerUsername);
            setOnTrack(peer, remoteVideo);
        
            mapPeers[peerUsername] = [peer, dataChannel];
        
            peer.addEventListener('icecandidate', (event) => {
                if (event.candidate) {
                    sendSignal('new-ice-candidate', {
                        candidate: event.candidate,
                        receiver_channel_name: receiverChannelName,
                    });
                }
            });
        
            peer.createOffer()
                .then((offer) => peer.setLocalDescription(offer))
                .then(() => {
                    sendSignal('new-offer', {
                        sdp: peer.localDescription,
                        receiver_channel_name: receiverChannelName,
                    });
                });
        }
        
        function createAnswer(peerUsername, offer, receiverChannelName) {
            const peer = new RTCPeerConnection();
            addLocalTracks(peer);
        
            const remoteVideo = createVideo(peerUsername);
            setOnTrack(peer, remoteVideo);
        
            peer.addEventListener('datachannel', (event) => {
                const dataChannel = event.channel;
                dataChannel.addEventListener('message', dcOnMessage);
                mapPeers[peerUsername] = [peer, dataChannel];
            });
        
            peer.addEventListener('icecandidate', (event) => {
                if (event.candidate) {
                    sendSignal('new-ice-candidate', {
                        candidate: event.candidate,
                        receiver_channel_name: receiverChannelName,
                    });
                }
            });
        
            peer.setRemoteDescription(new RTCSessionDescription(offer))
                .then(() => peer.createAnswer())
                .then((answer) => peer.setLocalDescription(answer))
                .then(() => {
                    sendSignal('new-answer', {
                        sdp: peer.localDescription,
                        receiver_channel_name: receiverChannelName,
                    });
                });
        }
        
        function addLocalTracks(peer) {
            localStream.getTracks().forEach((track) => peer.addTrack(track, localStream));
        }
        
        function createVideo(peerUsername) {
            const videoContainer = document.querySelector('#video-container');
            const videoWrapper = document.createElement('div');
            const videoElement = document.createElement('video');
            videoElement.autoplay = true;
            videoElement.playsInline = true;
        
            videoWrapper.appendChild(videoElement);
            videoContainer.appendChild(videoWrapper);
        
            return videoElement;
        }
        
        function setOnTrack(peer, remoteVideo) {
            const remoteStream = new MediaStream();
            remoteVideo.srcObject = remoteStream;
            peer.addEventListener('track', (event) => {
                remoteStream.addTrack(event.track);
            });
        }
        
    </script>



    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        h3 {
            text-align: center;
            color: #4a90e2;
        }

        .main-container {
            width: 90%;
            max-width: 1200px;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0px 4px 20px rgba(0, 0, 0, 0.1);
        }

        .main-grid-container {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        #video-container {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
        }

        video {
            border-radius: 15px;
            width: 100%;
            max-width: 500px;
            background-color: #333;
        }

        #chat {
            background-color: #f9f9f9;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.1);
        }

        #messages {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 10px;
            background-color: #fff;
            padding: 10px;
            border-radius: 10px;
            box-shadow: inset 0px 4px 10px rgba(0, 0, 0, 0.1);
        }

        #message-list {
            list-style-type: none;
            padding: 0;
        }

        #message-list li {
            margin-bottom: 10px;
            padding: 8px;
            background-color: #e0f7fa;
            border-radius: 10px;
            max-width: 80%;
            margin-left: 20px;
        }

        .btn {
            background-color: #4a90e2;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .btn:hover {
            background-color: #357ab7;
        }

        input, button {
            margin-bottom: 10px;
            padding: 10px;
            font-size: 16px;
            border-radius: 5px;
            width: 100%;
            border: 1px solid #ddd;
        }

        input {
            margin-bottom: 5px;
            width: calc(100% - 20px);
            box-sizing: border-box;
        }

        .btn-send-msg {
            width: auto;
            margin-left: 5px;
            cursor: pointer;
        }

        #btn-toggle-audio, #btn-toggle-video, #btn-share-screen {
            margin-top: 10px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

    </style>
</body>
</html>
